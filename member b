#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
#include <bitset>
#include <string>
using namespace std;

// Assume Implicant struct and helper functions exist from Part A.
// For testing this section alone, you can define a simple version here:
struct Implicant {
    string bits;             // e.g. "10-"
    vector<int> minterms;    // covered minterms
    bool used;               // if combined already
    bool isDontCare;         // optional
};

// Helper: count how many '1's are in a binary string (used for grouping)
int countOnes(const string &bits) {
    int cnt = 0;
    for (char c : bits)
        if (c == '1') cnt++;
    return cnt;
}

// ----------------------------
// STEP 10: Group Implicants by number of 1s
// ----------------------------
map<int, vector<Implicant>> groupByOnes(const vector<Implicant>& implicants) {
    map<int, vector<Implicant>> groups;
    for (auto &imp : implicants) {
        int ones = countOnes(imp.bits);
        groups[ones].push_back(imp);
    }
    return groups;
}

// ----------------------------
// STEP 11–13: Combine adjacent groups if differ by one bit
// ----------------------------
bool canCombine(const string &a, const string &b) {
    int diff = 0;
    for (size_t i = 0; i < a.size(); i++) {
        if (a[i] != b[i]) {
            diff++;
            if (diff > 1) return false;
        }
    }
    return diff == 1;
}

string mergeBits(const string &a, const string &b) {
    string merged = a;
    for (size_t i = 0; i < a.size(); i++) {
        if (a[i] != b[i]) merged[i] = '-';
    }
    return merged;
}

vector<Implicant> combineGroups(const map<int, vector<Implicant>>& groups) {
    vector<Implicant> newImplicants;
    set<string> existing;

    auto it = groups.begin();
    while (it != groups.end()) {
        auto nextIt = next(it);
        if (nextIt == groups.end()) break;

        for (auto &a : it->second) {
            for (auto &b : nextIt->second) {
                if (canCombine(a.bits, b.bits)) {
                    string mergedBits = mergeBits(a.bits, b.bits);
                    if (!existing.count(mergedBits)) {
                        Implicant newImp;
                        newImp.bits = mergedBits;
                        newImp.minterms = a.minterms;
                        newImp.minterms.insert(newImp.minterms.end(),
                                               b.minterms.begin(), b.minterms.end());
                        newImp.used = false;
                        newImp.isDontCare = false;
                        newImplicants.push_back(newImp);
                        existing.insert(mergedBits);
                    }
                    a.used = true;
                    b.used = true;
                }
            }
        }
        it++;
    }

    return newImplicants;
}

// ----------------------------
// STEP 14: Repeat combination until no new implicants
// ----------------------------
vector<Implicant> generatePrimeImplicants(vector<Implicant> implicants) {
    vector<Implicant> primeImplicants;
    bool canContinue = true;

    while (canContinue) {
        auto groups = groupByOnes(implicants);
        vector<Implicant> combined = combineGroups(groups);

        // Collect unused implicants (not combined)
        for (auto &imp : implicants) {
            if (!imp.used)
                primeImplicants.push_back(imp);
        }

        if (combined.empty()) {
            canContinue = false;
        } else {
            implicants = combined;
        }
    }
    return primeImplicants;
}

// ----------------------------
// STEP 15–17: Make prime implicant chart
// ----------------------------
map<int, vector<int>> makeChart(const vector<int>& minterms, const vector<Implicant>& primes) {
    map<int, vector<int>> chart;
    for (int i = 0; i < (int)primes.size(); i++) {
        for (int m : primes[i].minterms) {
            if (find(minterms.begin(), minterms.end(), m) != minterms.end()) {
                chart[m].push_back(i); // implicant i covers minterm m
            }
        }
    }
    return chart;
}

// ----------------------------
// STEP 18: Find essential prime implicants
// ----------------------------
vector<int> findEssentialPrimeImplicants(const map<int, vector<int>>& chart) {
    set<int> essentialIndices;
    for (auto &entry : chart) {
        if (entry.second.size() == 1) { // only one implicant covers this minterm
            essentialIndices.insert(entry.second[0]);
        }
    }
    return vector<int>(essentialIndices.begin(), essentialIndices.end());
}

// ----------------------------
// STEP 19–20: Remove covered minterms
// ----------------------------
vector<int> getCoveredMinterms(const vector<int>& essentials, const vector<Implicant>& primes) {
    set<int> covered;
    for (int idx : essentials) {
        for (int m : primes[idx].minterms)
            covered.insert(m);
    }
    return vector<int>(covered.begin(), covered.end());
}
